colnames(density_df) <- c("x", "y")
# Generate Synthetic HMC-like Trajectories
trajectory_hmc <- data.frame(
x = c(-3, -2, -1, 0, 1, 1.5),
y = c(-3, -2.5, -1, 1, 2, 2.5),
method = "HMC"
)
trajectory_ra_hmc <- data.frame(
x = c(-3, -1.5, -0.5, 0.5, 1.5, 2),
y = c(-3, -1.8, -1, 0, 1.5, 2.8),
method = "RA-HMC"
)
trajectory_neg_friction <- data.frame(
x = c(-3, -1, 0, 1, 3),
y = c(-3, -1, 0.5, 1.8, 3),
method = "Negative Friction"
)
# Combine all trajectories
trajectories <- bind_rows(trajectory_hmc, trajectory_ra_hmc, trajectory_neg_friction)
# Plot using ggplot2
ggplot() +
stat_density_2d(data = density_df, aes(x = x, y = y, fill = ..level..), geom = "polygon", alpha = 0.3) +
scale_fill_viridis_c(option = "magma") +
geom_path(data = trajectories, aes(x = x, y = y, color = method, group = method), size = 1.2) +
geom_point(data = trajectories, aes(x = x, y = y, color = method), size = 3, shape = 21, fill = "white") +
theme_void() +  # Removes background grid and axes
theme(legend.position = "bottom",
legend.title = element_blank())  # Removes legend title
#####################################
# Option - 1
#####################################
# Load required libraries
library(ggplot2)
library(MASS)        # For multivariate normal distribution
library(dplyr)       # For data wrangling
library(ggdensity)   # For nice KDE contour plots
# Simulate 2D Density Distributions
set.seed(42)
mu1 <- c(-2, -2)
mu2 <- c(2, 2)
sigma <- matrix(c(1, 0.5, 0.5, 1), 2, 2)
density1 <- mvrnorm(n = 500, mu = mu1, Sigma = sigma)
density2 <- mvrnorm(n = 500, mu = mu2, Sigma = sigma)
density_df <- as.data.frame(rbind(density1, density2))
colnames(density_df) <- c("x", "y")
# Generate Synthetic HMC-like Trajectories
trajectory_hmc <- data.frame(
x = c(-3, -2, -1, 0, 1, 1.5),
y = c(-3, -2.5, -1, 1, 2, 2.5),
method = "HMC"
)
trajectory_ra_hmc <- data.frame(
x = c(-3, -1.5, -0.5, 0.5, 1.5, 2),
y = c(-3, -1.8, -1, 0, 1.5, 2.8),
method = "RA-HMC"
)
trajectory_neg_friction <- data.frame(
x = c(-3, -1, 0, 1, 3),
y = c(-3, -1, 0.5, 1.8, 3),
method = "Negative Friction"
)
# Combine all trajectories
trajectories <- bind_rows(trajectory_hmc, trajectory_ra_hmc, trajectory_neg_friction)
# Plot using ggplot2
ggplot() +
stat_density_2d(data = density_df, aes(x = x, y = y, fill = ..level..), geom = "polygon", alpha = 0.3) +
scale_fill_viridis_c(option = "magma") +
geom_path(data = trajectories, aes(x = x, y = y, color = method, group = method), size = 1.2) +
geom_point(data = trajectories, aes(x = x, y = y, color = method), size = 3, shape = 21, fill = "white") +
theme_minimal() +
labs(title = "HMC vs RA-HMC Sampling Trajectories",
x = "X-axis", y = "Y-axis") +
theme(legend.position = "bottom")
#####################################
# Option - 2
#####################################
# Plot using ggplot2
ggplot() +
stat_density_2d(data = density_df, aes(x = x, y = y, fill = ..level..), geom = "polygon", alpha = 0.3) +
scale_fill_viridis_c(option = "magma") +
geom_path(data = trajectories, aes(x = x, y = y, color = method, group = method), size = 1.2) +
geom_point(data = trajectories, aes(x = x, y = y, color = method), size = 3, shape = 21, fill = "white") +
theme_void() +  # Removes background grid and axes
theme(legend.position = "bottom",
legend.title = element_blank())  # Removes legend title
# Plot using ggplot2
ggplot() +
stat_density_2d(data = density_df, aes(x = x, y = y, fill = ..level..), geom = "polygon", alpha = 0.3) +
scale_fill_viridis_c(option = "plasma") +
geom_path(data = trajectories, aes(x = x, y = y, color = method, group = method), size = 1.2) +
geom_point(data = trajectories, aes(x = x, y = y, color = method), size = 3, shape = 21, fill = "white") +
theme_void() +  # Removes background grid and axes
theme(legend.position = "bottom",
legend.title = element_blank())  # Removes legend title
ggplot() +
stat_density_2d(data = density_df, aes(x = x, y = y, fill = ..level..), geom = "polygon", alpha = 0.3) +
scale_fill_viridis_c(option = "inferno") +
geom_path(data = trajectories, aes(x = x, y = y, color = method, group = method), size = 1.2) +
geom_point(data = trajectories, aes(x = x, y = y, color = method), size = 3, shape = 21, fill = "white") +
theme_void() +  # Removes background grid and axes
theme(legend.position = "bottom",
legend.title = element_blank())
ggplot() +
stat_density_2d(data = density_df, aes(x = x, y = y, fill = ..level..), geom = "polygon", alpha = 0.3) +
scale_fill_viridis_c(option = "viridis") +
geom_path(data = trajectories, aes(x = x, y = y, color = method, group = method), size = 1.2) +
geom_point(data = trajectories, aes(x = x, y = y, color = method), size = 3, shape = 21, fill = "white") +
theme_void() +  # Removes background grid and axes
theme(legend.position = "bottom",
legend.title = element_blank())  # Removes legend title
ggplot() +
stat_density_2d(data = density_df, aes(x = x, y = y, fill = ..level..), geom = "polygon", alpha = 0.3) +
scale_fill_viridis_c(option = "cividis") +
geom_path(data = trajectories, aes(x = x, y = y, color = method, group = method), size = 1.2) +
geom_point(data = trajectories, aes(x = x, y = y, color = method), size = 3, shape = 21, fill = "white") +
theme_void() +  # Removes background grid and axes
theme(legend.position = "bottom",
legend.title = element_blank())  # Removes legend title
ggplot() +
stat_density_2d(data = density_df, aes(x = x, y = y, fill = ..level..), geom = "polygon", alpha = 0.3) +
scale_fill_viridis_c(option = "turbo") +
geom_path(data = trajectories, aes(x = x, y = y, color = method, group = method), size = 1.2) +
geom_point(data = trajectories, aes(x = x, y = y, color = method), size = 3, shape = 21, fill = "white") +
theme_void() +  # Removes background grid and axes
theme(legend.position = "bottom",
legend.title = element_blank())  # Removes legend title
# Plot using ggplot2
ggplot() +
stat_density_2d(data = density_df, aes(x = x, y = y, fill = ..level..), geom = "polygon", alpha = 0.3) +
scale_fill_viridis_c(option = "viridis") +
geom_path(data = trajectories, aes(x = x, y = y, color = method, group = method), size = 1.2) +
geom_point(data = trajectories, aes(x = x, y = y, color = method), size = 3, shape = 21, fill = "white") +
theme_void() +  # Removes background grid and axes
theme(legend.position = "bottom",
legend.title = element_blank())  # Removes legend title
# Plot using ggplot2
ggplot() +
stat_density_2d(data = density_df, aes(x = x, y = y, fill = ..level..), geom = "polygon", alpha = 0.3) +
scale_fill_gradientn(colors = terrain.colors(10)) +
geom_path(data = trajectories, aes(x = x, y = y, color = method, group = method), size = 1.2) +
geom_point(data = trajectories, aes(x = x, y = y, color = method), size = 3, shape = 21, fill = "white") +
theme_void() +  # Removes background grid and axes
theme(legend.position = "bottom",
legend.title = element_blank())  # Removes legend title
# Plot using ggplot2
ggplot() +
stat_density_2d(data = density_df, aes(x = x, y = y, fill = ..level..), geom = "polygon", alpha = 0.3) +
scale_fill_gradientn(colors = c("#FFC0CB", "#FF7F50", "#FF4500")) +
geom_path(data = trajectories, aes(x = x, y = y, color = method, group = method), size = 1.2) +
geom_point(data = trajectories, aes(x = x, y = y, color = method), size = 3, shape = 21, fill = "white") +
theme_void() +  # Removes background grid and axes
theme(legend.position = "bottom",
legend.title = element_blank())  # Removes legend title
## libraries
library(rgl)
## function for the level curve
lc <- function(x0, p0, beta = 0.5, t=5){
scl <- (beta-1)/(2*beta)
cyl.1 <- (sin(sqrt(beta)*t)^2)*(p0^2 - x0^2*beta)
cyl.2 <- sin(sqrt(beta)*t)*cos(sqrt(beta)*t)*(2*beta*x*p0)
return (scl*(cyl.1+cyl.2))
}
x0 <- seq(-500,500, length = 1e3)
p0 <- seq(-500,500, length = 1e3)
## X0 P0 plot
z <- outer(x0, p0, lc)
## libraries
library(rgl)
## function for the level curve
lc <- function(x0, p0, beta = 0.5, t=5){
scl <- (beta-1)/(2*beta)
cyl.1 <- (sin(sqrt(beta)*t)^2)*(p0^2 - x0^2*beta)
cyl.2 <- sin(sqrt(beta)*t)*cos(sqrt(beta)*t)*(2*beta*x*p0)
return (scl*(cyl.1+cyl.2))
}
x0 <- seq(-500,500, length = 1e3)
p0 <- seq(-500,500, length = 1e3)
## X0 P0 plot
z <- outer(x0, p0, lc)
## libraries
library(rgl)
## function for the level curve
lc <- function(x0, p0, beta = 0.5, t=5){
scl <- (beta-1)/(2*beta)
cyl.1 <- (sin(sqrt(beta)*t)^2)*(p0^2 - x0^2*beta)
cyl.2 <- sin(sqrt(beta)*t)*cos(sqrt(beta)*t)*(2*beta*x0*p0)
return (scl*(cyl.1+cyl.2))
}
x0 <- seq(-500,500, length = 1e3)
p0 <- seq(-500,500, length = 1e3)
## X0 P0 plot
z <- outer(x0, p0, lc)
plot3d(x0, p0, z)
plot3d(x0, p0, lc(x0,po))
plot3d(x0, p0, lc(x0,p0))
x0 <- seq(-100,100, length = 1e3)
p0 <- seq(-100,100, length = 1e3)
## X0 P0 plot
z <- outer(x0, p0, lc)
plot3d(x0, p0, lc(x0,p0))
plot3d(x0, p0, z)
## libraries
library(rgl)
## function for the level curve
lc <- function(x0, p0, beta = 0.5, t=5){
scl <- (beta-1)/(2*beta)
cyl.1 <- (sin(sqrt(beta)*t)^2)*(p0^2 - x0^2*beta)
cyl.2 <- sin(sqrt(beta)*t)*cos(sqrt(beta)*t)*(2*beta*x0*p0)
return (scl*(cyl.1+cyl.2))
}
x0 <- seq(-1000,1000, length = 1e3)
p0 <- seq(-1000,1000, length = 1e3)
## X0 P0 plot
z <- outer(x0, p0, lc)
plot3d(x0, p0, z)
## libraries
library(rgl)
## function for the level curve
lc <- function(x0, p0, beta = 0.5, t=5){
scl <- (beta-1)/(2*beta)
cyl.1 <- (sin(sqrt(beta)*t)^2)*(p0^2 - x0^2*beta)
cyl.2 <- sin(sqrt(beta)*t)*cos(sqrt(beta)*t)*(2*beta*x0*p0)
return (scl*(cyl.1+cyl.2))
}
x0 <- seq(-1000,1000, length = 2e3)
p0 <- seq(-1000,1000, length = 2e3)
## X0 P0 plot
z <- outer(x0, p0, lc)
plot3d(x0, p0, z)
## libraries
library(rgl)
## function for the level curve
lc <- function(x0, p0, beta = 0.5, t=5){
scl <- (beta-1)/(2*beta)
cyl.1 <- (sin(sqrt(beta)*t)^2)*(p0^2 - x0^2*beta)
cyl.2 <- sin(sqrt(beta)*t)*cos(sqrt(beta)*t)*(2*beta*x0*p0)
return (scl*(cyl.1+cyl.2))
}
x0 <- seq(-1000,1000, length = 3e3)
p0 <- seq(-1000,1000, length = 3e3)
## X0 P0 plot
z <- outer(x0, p0, lc)
plot3d(x0, p0, z)
x0 <- seq(-1000,1000, length = 4e3)
p0 <- seq(-1000,1000, length = 4e3)
## X0 P0 plot
z <- outer(x0, p0, lc)
plot3d(x0, p0, z)
x0 <- seq(-1000,1000, length = 5e3)
p0 <- seq(-1000,1000, length = 5e3)
## X0 P0 plot
z <- outer(x0, p0, lc)
plot3d(x0, p0, z)
# Sample 10k observations with class balance
df_sample <- df %>%
group_by(is_fraud) %>%
sample_n(size = min(5000, n()), replace = FALSE) %>%
ungroup()
## Loading the required libraries
library(dplyr)
library(lubridate)
library(tidyr)
library(caret)
library(e1071)
library(cluster)
library(dbscan)
library(solitude)   # Isolation Forest
library(depmixS4)   # HMMs
library(reticulate) # Python interface
library(ggplot2)
library(nimble)     # MCMC implementation (bonus)
## Reading the data
df <- read.csv("../Data/fraudTrain.csv")
setwd("~/Course Work/SEM-6/MTH443/MTH443-GroupProject/Code")
## Loading the required libraries
library(dplyr)
library(lubridate)
library(tidyr)
library(caret)
library(e1071)
library(cluster)
library(dbscan)
library(solitude)   # Isolation Forest
library(depmixS4)   # HMMs
library(reticulate) # Python interface
library(ggplot2)
library(nimble)     # MCMC implementation (bonus)
## Reading the data
df <- read.csv("../Data/fraudTrain.csv")
set.seed(123)
# Sample 10k observations with class balance
df_sample <- df %>%
group_by(is_fraud) %>%
sample_n(size = min(5000, n()), replace = FALSE) %>%
ungroup()
# Preprocess this sample the same way
df_sample$trans_date_trans_time <- ymd_hms(df_sample$trans_date_trans_time)
df_sample$dob <- ymd(df_sample$dob)
df_sample$age <- as.integer(time_length(difftime(df_sample$trans_date_trans_time, df_sample$dob), "years"))
df_sample$hour <- hour(df_sample$trans_date_trans_time)
df_sample$distance <- sqrt((df_sample$lat - df_sample$merch_lat)^2 + (df_sample$long - df_sample$merch_long)^2)
features <- df_sample %>%
dplyr::select(amt, age, city_pop, hour, distance) %>%
drop_na()
features_scaled <- scale(features)
## Isolation Forest
iso <- isolationForest$new()
iso$fit(features)
df$iso_score <- iso$predict(features)$anomaly_score
df_sample$iso_score <- iso$predict(features)$anomaly_score
## One class SVM
svm_model <- svm(features_scaled, type = "one-classification", kernel = "radial", nu = 0.05)
df_sample$svm_pred <- predict(svm_model, features_scaled)
## DBSCAN
db <- dbscan(features_scaled, eps = 1.5, minPts = 10)
df_sample$dbscan_cluster <- db$cluster
df_sample$dbscan_anomaly <- ifelse(df_sample$dbscan_cluster == 0, 1, 0)
user_data <- df_sample %>%
filter(cc_num == df_sample$cc_num[1]) %>%
arrange(trans_date_trans_time)
obs <- user_data$amt
hmm_model <- depmix(amt ~ 1, family = gaussian(), nstates = 3, data = data.frame(amt = obs))
hmm_fit <- fit(hmm_model)
hmm_model <- depmix(amt ~ 1, family = gaussian(), nstates = 3, data = data.frame(amt = obs))
hmm_fit <- fit(hmm_model)
ggplot(df_sample, aes(x = iso_score, fill = as.factor(is_fraud))) +
geom_density(alpha = 0.5) +
labs(title = "Isolation Forest Anomaly Score by Class",
x = "Anomaly Score", fill = "Is Fraud") +
theme_minimal()
library(reshape2)
detect_mat <- df_sample %>%
dplyr::select(is_fraud, iso_score, svm_pred, dbscan_anomaly) %>%
mutate(
iso_flag = ifelse(iso_score > 0.65, 1, 0)  # You can tune this
) %>%
dplyr::select(is_fraud, iso_flag, svm_pred, dbscan_anomaly)
detect_long <- melt(detect_mat, id.vars = "is_fraud")
ggplot(detect_long, aes(x = variable, fill = as.factor(value))) +
geom_bar(position = "fill") +
facet_wrap(~is_fraud, labeller = labeller(is_fraud = c("0" = "Not Fraud", "1" = "Fraud"))) +
labs(y = "Proportion", fill = "Flagged", title = "Model Flags by Fraud Status")
## HMMs
user_data <- df_sample %>%
filter(cc_num == df_sample$cc_num[1]) %>%
arrange(trans_date_trans_time)
obs <- user_data$amt
hmm_model <- depmix(amt ~ 1, family = gaussian(), nstates = 3, data = data.frame(amt = obs))
hmm_fit <- fit(hmm_model)
summary(features)
any(is.na(features))             # Should be FALSE
any(is.infinite(as.matrix(features)))  # Should also be FALSE
features <- as.data.frame(lapply(features, function(x) ifelse(is.infinite(x), NA, x)))
features <- features[complete.cases(features), ]
apply(features, 2, sd)
hmm_model <- depmix(
list(amt ~ 1, hour ~ 1),
data = features_scaled,
nstates = 2,
family = list(gaussian(), gaussian())
)
features_scaled <- as.data.frame(scale(features))
hmm_model <- depmix(
list(amt ~ 1, hour ~ 1),
data = features_scaled,
nstates = 2,
family = list(gaussian(), gaussian())
)
# Try fitting again
set.seed(123)
hmm_fit <- fit(hmm_model)
summary(hmm_fit)
posterior_probs <- posterior(hmm_fit)
df_sample$state <- posterior_probs$state
ggplot(df_sample, aes(x = amt, fill = factor(state))) +
geom_histogram(bins = 50, position = "identity", alpha = 0.6) +
labs(title = "Transaction Amounts by HMM-Inferred State", fill = "HMM State")
# Assign meaningful labels to the states based on average amount (as proxy for risk)
state_summary <- df_sample %>%
group_by(state) %>%
summarise(mean_amt = mean(amt, na.rm = TRUE)) %>%
arrange(desc(mean_amt)) %>%
mutate(risk_label = c("High-Risk", "Low-Risk"))
# Merge labels back to the data
df_sample <- df_sample %>%
left_join(state_summary %>% select(state, risk_label), by = "state")
# Merge labels back to the data
df_sample <- df_sample %>%
left_join(state_summary %>% dplyr::select(state, risk_label), by = "state")
# Plot with better labels and limits
ggplot(df_sample, aes(x = amt, fill = risk_label)) +
geom_histogram(bins = 50, position = "identity", alpha = 0.6) +
scale_fill_manual(values = c("High-Risk" = "#e74c3c", "Low-Risk" = "#2ecc71")) +
xlim(0, quantile(df_sample$amt, 0.99)) +
labs(
title = "Transaction Amount Distribution by HMM-Inferred Risk",
x = "Transaction Amount",
y = "Count",
fill = "HMM-Inferred Risk"
) +
theme_minimal(base_size = 14)
library(igraph)
# Sample smaller subset for speed
df_graph <- df %>%
select(cc_num, merchant, trans_date_trans_time, is_fraud) %>%
mutate(trans_date = ymd_hms(trans_date_trans_time)) %>%
arrange(trans_date) %>%
distinct()
### Tree based Detection
# Sample smaller subset for speed
df_graph <- df %>%
dplyr::select(cc_num, merchant, trans_date_trans_time, is_fraud) %>%
mutate(trans_date = ymd_hms(trans_date_trans_time)) %>%
arrange(trans_date) %>%
distinct()
# Build edge list: card numbers using the same merchant
edge_list <- df_graph %>%
group_by(merchant) %>%
filter(n() > 1) %>%  # Only merchants with >1 transaction
summarise(pairs = combn(cc_num, 2, simplify = FALSE)) %>%
unnest(pairs) %>%
mutate(
from = map_chr(pairs, 1),
to = map_chr(pairs, 2)
) %>%
select(from, to)
# Build edge list: card numbers using the same merchant
edge_list <- df_graph %>%
group_by(merchant) %>%
filter(n() > 1) %>%  # Only merchants with >1 transaction
summarise(pairs = combn(cc_num, 2, simplify = FALSE)) %>%
unnest(pairs) %>%
mutate(
from = map_chr(pairs, 1),
to = map_chr(pairs, 2)
) %>%
dplyr::select(from, to)
### Tree based Detection
# Sample smaller subset for speed
df_graph <- df_sample %>%
dplyr::select(cc_num, merchant, trans_date_trans_time, is_fraud) %>%
mutate(trans_date = ymd_hms(trans_date_trans_time)) %>%
arrange(trans_date) %>%
distinct()
### Tree based Detection
# Sample smaller subset for speed
df_graph <- df_sample %>%
dplyr::select(cc_num, merchant, trans_date_trans_time, is_fraud) %>%
mutate(trans_date = trans_date_trans_time) %>%
arrange(trans_date) %>%
distinct()
# Build edge list: card numbers using the same merchant
edge_list <- df_graph %>%
group_by(merchant) %>%
filter(n() > 1) %>%  # Only merchants with >1 transaction
summarise(pairs = combn(cc_num, 2, simplify = FALSE)) %>%
unnest(pairs) %>%
mutate(
from = map_chr(pairs, 1),
to = map_chr(pairs, 2)
) %>%
dplyr::select(from, to)
## Loading the required libraries
library(dplyr)
library(lubridate)
# Build edge list: card numbers using the same merchant
edge_list <- df_graph %>%
group_by(merchant) %>%
filter(n() > 1) %>%  # Only merchants with >1 transaction
summarise(pairs = combn(cc_num, 2, simplify = FALSE)) %>%
unnest(cols = pairs) %>%
mutate(
from = sapply(pairs, `[`, 1),  # Extract first element of the pair
to = sapply(pairs, `[`, 2)     # Extract second element of the pair
) %>%
dplyr::select(from, to)
View(df_graph)
edge_list <- df_graph %>%
group_by(merchant)
edge_list <- df_graph %>%
group_by(merchant) %>%
filter(n() > 1)
edge_list <- df_graph %>%
group_by(merchant) %>%
filter(n() > 1) %>%  # Only merchants with >1 transaction
summarise(pairs = combn(cc_num, 2, simplify = FALSE))
edge_list <- df_graph %>%
group_by(merchant) %>%
filter(n() > 1) %>%  # Only merchants with >1 transaction
summarise(pairs = combn(cc_num, 2, simplify = FALSE)) %>%
unnest(cols = pairs) %>%
mutate(
from = sapply(pairs, `[`, 1),  # Extract first element of the pair
to = sapply(pairs, `[`, 2)     # Extract second element of the pair
) %>%
dplyr::select(from, to)
# Create the graph
g <- graph_from_data_frame(edge_list, directed = FALSE)
# Add node attributes
V(g)$fraud <- ifelse(V(g)$name %in% df_graph$cc_num[df_graph$is_fraud == 1], 1, 0)
# Detect communities
communities <- cluster_louvain(g)
V(g)$community <- communities$membership
# Visualize with fraud coloring
plot(
g,
vertex.label = NA,
vertex.size = 3,
vertex.color = ifelse(V(g)$fraud == 1, "red", "lightblue"),
main = "Graph-Based Fraud Network",
layout = layout_with_fr(g)
)
